- [第一章 操作系统概述](#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0)
  - [基本构成](#%e5%9f%ba%e6%9c%ac%e6%9e%84%e6%88%90)
  - [存储器的层次结构](#%e5%ad%98%e5%82%a8%e5%99%a8%e7%9a%84%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84)
- [第2章 操作系统概述](#%e7%ac%ac2%e7%ab%a0-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0)
  - [1.  操作系统的目标与功能](#1-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%9b%ae%e6%a0%87%e4%b8%8e%e5%8a%9f%e8%83%bd)
  - [2. 操作系统的发展](#2-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%8f%91%e5%b1%95)
  - [3. 主要成就](#3-%e4%b8%bb%e8%a6%81%e6%88%90%e5%b0%b1)
  - [4. 现代操作系统](#4-%e7%8e%b0%e4%bb%a3%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f)
- [第3章 进程描述与控制](#%e7%ac%ac3%e7%ab%a0-%e8%bf%9b%e7%a8%8b%e6%8f%8f%e8%bf%b0%e4%b8%8e%e6%8e%a7%e5%88%b6)
  - [1. 进程的概念](#1-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%a6%82%e5%bf%b5)
  - [2. 进程的状态](#2-%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81)
  - [3. 进程的描述](#3-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%8f%8f%e8%bf%b0)
  - [4. 进程的控制](#4-%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%8e%a7%e5%88%b6)
  - [5. 计算机的执行](#5-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%9a%84%e6%89%a7%e8%a1%8c)
- [第四章 线程](#%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e7%ba%bf%e7%a8%8b)
  - [线程概念](#%e7%ba%bf%e7%a8%8b%e6%a6%82%e5%bf%b5)
  - [线程的分类](#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%88%86%e7%b1%bb)
    - [win8的进程线程管理](#win8%e7%9a%84%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e7%ae%a1%e7%90%86)
    - [Linux的进程和线程](#linux%e7%9a%84%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b)
- [第五章 并发性: 互斥和同步](#%e7%ac%ac%e4%ba%94%e7%ab%a0-%e5%b9%b6%e5%8f%91%e6%80%a7-%e4%ba%92%e6%96%a5%e5%92%8c%e5%90%8c%e6%ad%a5)
  - [互斥: 硬件的支持](#%e4%ba%92%e6%96%a5-%e7%a1%ac%e4%bb%b6%e7%9a%84%e6%94%af%e6%8c%81)
  - [信号量](#%e4%bf%a1%e5%8f%b7%e9%87%8f)
  - [管程](#%e7%ae%a1%e7%a8%8b)
  - [消息传递](#%e6%b6%88%e6%81%af%e4%bc%a0%e9%80%92)
  - [读者/写者问题](#%e8%af%bb%e8%80%85%e5%86%99%e8%80%85%e9%97%ae%e9%a2%98)
- [第六章 并发:死锁与饥饿](#%e7%ac%ac%e5%85%ad%e7%ab%a0-%e5%b9%b6%e5%8f%91%e6%ad%bb%e9%94%81%e4%b8%8e%e9%a5%a5%e9%a5%bf)
- [第九章 处理器调度](#%e7%ac%ac%e4%b9%9d%e7%ab%a0-%e5%a4%84%e7%90%86%e5%99%a8%e8%b0%83%e5%ba%a6)
  - [进程调度算法](#%e8%bf%9b%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95)


# 第一章 操作系统概述

## 基本构成
**1.计算机组成**
处理器 内存 I/O设备 系统总线
寄存器类型：存储器地址寄存器：用于确定下一次读写的存储器地址 存储器缓存寄存器：用于存放要写入存储器的数据或从存储器读取的数据
**2.  指令的类型**
处理器与存储器，处理器与外部设备，控制， 数据处理
指令周期：一个指令周期包括取指阶段和执行阶段，有中断的情况下还有中断情况检查阶段
**3. 中断**
处理器在执行程序时，遇到意外的外部情况时，能够自动的停止当前的程序，转入意外情况的处理程序，在处理后能够自动转回到当前正在执行的程序的功能。
中断类型

![mark](http://cdn.hustcaid.com/pictures/20190130/nAUc8PU3l0SR.jpg?imageslim)

中断处理的两种策略：在处理中断时禁止处理新的中断；根据中断的优先级决定处理的中断。
存在中断时的控制流

![中断流程](http://cdn.hustcaid.com/pictures/20190130/OTm9jIaxB5aY.jpg?imageslim)

## 存储器的层次结构
存储器层次：板上存储器，板外存储器，离线存储器
- 容量依次增加，速度依次减慢，原理：低层次访问频率递减——时间局部性和空间局部性
- 时间局部性： 存储器上被访问一次的位置在近期可能被再次访问
- 空间局部性：存储器上被访问的位置的附近在近期可能被访问
- I/O操作的三种方式：可编程I/O， 中断I/O，DMA
  - 可编程I/O：线性使用处理器，在进行I/O时等待
  - 中断I/O：并行的执行I/O通过中断，开始和结束处理
  - DMA：独立模块，读写完成时提出中断

多处理器和多核处理器
- 多处理器：处理器之间相互独立，有自己的寄存器和缓存，当一个失效时其他继续工作，具有伸缩性
- 多核处理器：多个处理器组装在同一个硅片上，有独立的一二级缓存，共享三级缓存

# 第2章 操作系统概述

## 1.  操作系统的目标与功能
操作系统的目标：
- 有效
- 方便
- 拓展能力
操作系统的典型接口：
- 指令系统体系结构（ISA）
- 应用程序二进制接口（ABI）
- 应用程序编程接口（API）
内核：内核程序包含操作系统中最常使用的功能： 进程管理，中断异常处理，同步等
## 2. 操作系统的发展
- 串行处理
- 批处理系统
    监控程序作为一个计算机程序，依赖处理器可以从内存不同部分取址的能力，交替释放和获取控制权
    批处理系统中的监控程序已经具有了内存保护、特权指令、定时器、中断功能。处理器的运行分为用户态和内核态两种状态。只有在内核态下，处理器才可以执行特权指令和访问受保护的内存地址。
- 多道批处理系统
    多道程序设计，将多个程序加载到内存，在不同的程序之间进行切换，提高处理器的使用效率。
    多道批处理系统的重要辅助功能：I/O中断和DMA， 同时开始具有内存调度和内存管理算法
- 分时系统
分时系统和批处理系统的不同
## 3. 主要成就
**进程**

进程的组成
- 一段可执行程序
- 程序需要的相关数据（变量、工作空间、缓存）
- 执行上下文
    - 执行上下文：是操作系统管理和控制进程所需的内部数据，包括各种处理器寄存器的内容，如程序计数器和数据寄存器；操作系统使用的信息，如优先级和是否等待资源。

线程：一个被分配资源的进程可以分解为多个并发的线程，相互协作执行完成任务。

**内存管理**

基本的存储器管理职责：
- 进程隔离
- 内存的自动分配和回收
- 长期储存
- 支持模块化程序设计
- 保护和访问机制

虚地址：由页号和页偏移组成的分页系统中的内存地址。 实地址： 内容的物理地址。

**调度与资源管理的要求**
- 公平性
- 有差别的响应性
- 高效性

## 4. 现代操作系统
单体内核/微内核： 单体内核集成了文件管理、存储管理、设备管理等较多功能，通过一个进程执行，共享地址空间。微内核只给内核分配一些基本的功能，包括地址空间，进程间通信和基本的调度。剩下的系统服务以一般的用户态进程的形式提供。
多核处理的设计考虑因素
- 并发进程或线程
- 调度
- 同步
- 内存管理
- 可靠性和兼容性

# 第3章 进程描述与控制

## 1. 进程的概念

进程的定义:
- 一个正在执行的程序
- 一个正在计算机上执行的程序实例
- 能够分配给处理器并由处理器执行的实体
- 一个具有以下特征的活动单元: 一组指令序列的执行, 一个当前状态, 一个系统资源集

**进程控制块**是使系统支持多重处理技术的关键工具.当进程中断时, 操作系统会把程序计数器和处理器寄存器(上下文数据)写入到进程控制块的相应位置, 进程控制块中包含足够充分的信息, 保证在中断后恢复现场时能够像从来没有中断过一样.

## 2. 进程的状态


进程的创建的四种原因
![](http://cdn.hustcaid.com/FulRePF73uIANSynkKHBQ5Qw675k.jpg)

进程终止的原因
![](http://cdn.hustcaid.com/Fg8S2V4yRW9rGrB0s5IL15SKztl4.jpg)

**抢占** 当优先级更高的进程出现在就绪态, 操作系统中断当前进程的执行,将处理器分派给优先级更高的进程的现象.

为什么需要多个阻塞队列?
- 一个事件对应一个队列,减少事件发生时的检索开销.

七状态模型
- 新建态: 刚刚创建的进程, 通常进程控制块已经创建, 但还没有加载到内存中的新进程
- 就绪态: 进程做好准备只要有机会就可以运行
- 运行态: 进程占用处理器, 正在执行
- 退出态: 操作系统从执行进程组中释放的进程, 因自身停止或因某种原因被取消
- 阻塞态: 进程在内存中, 在某些事件发生前不能执行
- 挂起/阻塞态: 进程被交换到外存中等待某一事件的发生
- 挂起/就绪态: 进程被交换到外存中, 等待操作系统将其转移到内存上并可以执行

![七状态转换模型](http://cdn.hustcaid.com/FnqCWMbthY7E9aEVi2yALceQHqJy.jpg)

新建态的两步:
- 将标识符关联到进程, 分配和创建进程所需要的所有表[创建pcb]
- 进程处于新建态时, 操作系统所需要的关于该进程的信息保存在内存的进程表中, 但进程尚未进入内存,即执行的程序代码不在内存中, 也没有为这个程序的相关数据分配空间.[代码数据没有在内存中分配空间]

退出态的两步:
- 进程到达自然结束点或出现不可恢复的错误而取消时, 进程被终止, 转入退出态
- 辅助程序或支持程序提取必要的分析信息,供分析性能和利用率

**交换** 把内存的某个进程一部分或全部移到磁盘中
> 交换是一个I/O操作, 可能使问题更加恶化. 虚拟内存的使用看上去消除了显式交换的需求, 因为通过处理器中的储存管理硬件, 任何期望的进程中的任何期望的地址都可以移入或移出内存. 即使在虚拟存储系统中, 操作系统也需要不时的更具执行情况, 显式的,完全的换出进程.

挂起的特点:
- 进程不能被立刻执行
- 挂起条件和阻塞条件独立, 进程可能在也可能不在等待一个事件
- 为阻止这个进程的执行, 可以通过代理把这个进程置于挂起状态, 代理可以是自己, 父进程或操作系统.
- 除非代理显式的要求系统进行状态转换, 否则进程无法从这个状态转移.

## 3. 进程的描述

问题: 操作系统为了控制进程和管理资源需要哪些信息?
- 为内存, 设备, 文件和进程维护四个实体信息表;
- 四个表之间有存在交叉引用, 例如I/O设备可能打开某些文件

进程映像的成员: 用户程序 用户数据 栈 进程控制块

![映像在虚存中的结构](http://cdn.hustcaid.com/FpaOLuDZDxD4euLczOmhmMQTwk1I.jpg)

PCB包含的信息
- 标识信息 包括进程ID 父进程ID 用户标识符
- 状态信息 寄存器信息(用户可见的寄存器, 程序状态寄存器) 栈指针
- 控制信息 调度信息, 用于放到进程链表的数据结构 资源所有权和使用情况 进程间通信 进程特权 存储管理(指向虚存的段表和页表的指针)

## 4. 进程的控制
模式切换: 处理中断时首先要从用户模式切换到内核模式, 这个切换只需要保存当前进程的寄存器和栈信息

进程切换: 发生在操作系统从当前进程获得控制权的时刻(包括中断, 陷阱, 系统调用); 进程切换会首先保存处理器上下文, 更新进程控制块状态, 吧进程控制块移到相应的链表, 选择另一个进程, 更新所选进程控制块, 更新内存管理数据结构 

进程切换一定包含模式切换, 模式切换后有可能维持原来的进程继续

中断和陷阱的比较: 两者都是系统中断, 前者是由于发生与当前进程无关的外部事件产生, 如一次I/O完成等;后者是由于进程自身产生错误或异常, 如非法的文件访问. 
- 普通中断包括例如: 时钟中断, I/O中断, 内存失效中断等. 
- 此外还有一种引起进程切换的原因是系统调用, 是进程的显示请求调用操作系统函数,使用系统调用时会将用户进程设为阻塞态

模式切换和进程切换的比较: 进程切换一定包含模式切换, 但模式切换到内核模式后仍可能返回继续执行原进程, 也可能调度其他进程.模式切换只需要保存寄存器和栈信息, 而进程切换则需要做更多工作.

## 5. 计算机的执行
![内核模型](http://cdn.hustcaid.com/Fqg6F2rGqhsYxKjCU1SYLu9124mm.jpg)

三种内核模型

- 无进程内核: 独立于进程之外运行的内核; 进程概念只适用于用户进程, 操作系统代码是在特权模式下运行的独立实体
- 在用户进程内运行: 每个用户进程都包含一个用户栈和内核栈, 和一个共享地址空间, 操作系统代码位于共享地址空间, 当用户进程切换到特权模式时不用切换进程,在本进程内利用内核栈就可以完成操作系统需要运行的代码;在一个进程中, 用户程序和操作系统程序都可以执行, 而不同用户进程中执行的操作系统程序是相同的.
- 基于进程的操作系统: 内核功能被组织成一组独立的进程, 任何进程外还存在一部分切换代码. 模块化, 提高性能. 

在Unix中, 系统启动时, 首先会启动0号进程, 是进程切换器, 0号进程派生出1号进程, 是所有进程的根进程, 当一个用户进程处于僵死状态后, 由父进程完成最后处理工作, 但是如果这时父进程已经退出, root进程会定期清理僵尸进程.

Unix属于第二种, 在用户进程内运行, 状态转化模型中增加了僵死状态, 将运行态拆成内核运行态和用户运行态两个部分.

僵死状态下, 进程已经不再存在, 但它留下了一条其父进程可以收集的记录(fork创建子进程, 在wait函数中处理子进程的僵死状态, 为子进程收尾)


# 第四章 线程

## 线程概念

进程与线程的区别与联系:
- 进程是资源管理与分配的基本单位, 负责管理文件, 设备, 内存, 其他进程(进程间通信)等资源的管理, 拥有虚拟地址空间
- 线程是程序执行的最小单位, 包括了线程上下文, 执行栈, 局部变量的存储空间, 同一进程中的线程共享内存和资源

线程相比进程的优点:
- 创建, 终止线程更快
- 线程的切换更快
- 线程之间的通信不需要内核介入

线程的状态: 运行态,就绪态, 阻塞态

## 线程的分类

用户级线程: 
- 在用户空间实现的线程, 通过线程库实现, 操作系统对其无感知
- 优点:
  - 线程切换不需要模式切换, 效率高
  - 可以自定义调度算法, 适应应用程序的需要
  - 不依赖系统, 可以在任何系统运行
- 缺点:
  - 一个线程阻塞导致整个进程阻塞
  - 同一时刻只有一个线程运行, 不能够很好利用多核处理器的优势
- 解决方法:
  - Pipline: 将会产生阻塞的调用变成非阻塞调用
  - 实现多进程程序而非多线程程序

内核级线程
- 在操作系统层面支持的线程, 通过调用操作系统提供的api进行调用, 内核维护和调用线程
- 优点是一个线程阻塞了可以调用另一个线程而不会导致整个进程阻塞
- 缺点是需要模式切换, 速度比用户级线程慢, 比多进程快

混合方法
- 线程的创建完全在用户空间, 线程的调度和同步也是在应用程序进行, 但是多个用户级线程被映射到一些内核级线程上(小于等于).

衡量多核性能

$$加速比=\frac{在单个处理器上的执行时间}{在N个并行处理器上执行程序的时间}=\frac{1}{(1-f)+f/N}$$

### win8的进程线程管理
- 线程池: 为减少应用程序的线程数量
- 纤程: 必须由应用程序来调度的可执行单元. 用于管理和调度线程

### Linux的进程和线程
老版本Linux上没有线程的概念,  需要使用线程库实现用户级线程, 最著名的线程库就是pthread库. 现代Linux提供一种不区分线程和进程的方案, 将用户级线程映射成内核级进程, 一个用户级进程的多个用户级线程映射到的多个内核级进程可以共享一个组ID, 他们共享文件和内存等资源, 使得它们切换时不需要切换上下文.

Linux的命名空间
- 命名空间使得与某一个命名空间关联的进程与其他相关命名空间的其他进程有不同的系统视图, 就是它只能感知同一个命名空间下的进程的存在, 不同命名空间下的进程之间无法通信
- 当前linux的6种命名空间: mount, pid, net, ipc, uts, user
- 命名空间的总体目标是为实现控制组cgroup提供支持(也称容器), 控制组是一个轻量级的可视化工作, 使进程或进程组认为自己是系统的唯一进程.
- 命名空间由系统调用`clone()`创建, 用六种空间名之一作为参数; 也可以用`unshare()`调用创建, 区别在于`clone`会创建新的进程, 而`unshare`只会创建新的命名空间而不会创建进程.
- 在任何时刻一个网络设备只能属于一个命名空间, 一个套接字也只能属于一个命名空间. docker可以通过虚拟网卡来实现每个容器的网络设备.虚拟网卡通过网桥连接到物理网卡.

# 第五章 并发性: 互斥和同步

- 竞态条件: 多个进程同时访问不可共享资源的状态
- 临界区: 一段同时只允许一个线程执行的代码代码段或只允许一个线程操纵的资源
- 互斥: 某个任务运行一个程序片段时, 其他任务不能够运行同一个程序片段
- 同步: 若干程序片段的执行必须要按照特定的次序.
- 死锁概念: 进程之间相互等待对方占有的资源而无法运行的情况
- 饥饿概念: 由于资源分配策略不公平导致某些进程持续得不到资源或不能执行
- 线程之间的通信机制: 共享内存和消息传递

## 互斥: 硬件的支持
CAS: 硬件指令 将寄存器上的值与old参数比较, 如果相等将寄存器设为new参数, 返回寄存器上原有的值

exchange: 交换内存和寄存器中的值

自旋等待: 用while循环使得线程进入忙等, 依然会消耗CPU资源, 适合临界区较小的情况.

通过屏蔽中断或机器指令进行互斥的特点:
- 只能用于单处理器
- 可以支持多个临界区
- 简单容易证明

## 信号量
一个包含两种原子操作(P,V)的整型量, P是变量-1, 当变量小于0时, 将当前进程阻塞挂到该信号量的队列中; V是变量+1, 当变量小于等于0时, 唤醒至少一个挂在当前信号量上的进程.

 信号量的物理含义: 正数表示可用的资源数量, 负数表示等待该资源的进程数量.

 用信号量解决生产者消费者问题
 ```java
 class resource {
   mutex m1;
   semphore emptyBuffer = n, fullBuffer = 0;
 }

 class test {
   producer() {
     while (true) {
       emptyBuffer.P();
       m1.P();
       // fill buffer
       m1.V();
       fullBuffer.V();
     }
   }
   consumer() {
     while (true) {
       fullBuffer.P();
       m1.P();
       // get buffer
       m1.V();
       emptyBuffer.V();
     }
   }
 }
 ```
## 管程
管程是对并发机制的一种抽象, 将临界资源纳入到管程中管理, 进程通过管程操作资源, 管程来保证同一时刻只有一个进程能够拿到**管程中的锁**, 操作管程管理的临界资源.
- 管程已经抽象出了锁的概念
- 管程中维护条件变量, 一个条件变量需要维护一个等待这个条件的进程的队列, 进程等待的条件等待signal.

```java
class condition {
  int numWaiting = 0;
  waitingQueue q;

  wait(lock) {
    numWaiting++;
    // add thread to q
    release(lock);
    schedule();
    require(lock);
  }

  signal() {
    if (numWaiting > 0) {
      // remove a thread from q
      wakeup(t);
      numWaiting--;
    }
  }
}
```

用管程实现生产者/消费者模型
```java
class BoundedBuffer {
  ...
  Lock lock;
  cond notEmpty, notFull;
  int count = 0;

  void product() {
    require(lock);
    while (count == n) notFull.wait(lock);
    // Add c to Buffer
    count++;
    notEmpty.signal();
    release(lock);
  }
  void consume() {
    require(lock);
    while (count == 0) notEmpty.wait(lock);
    // remove c from Buffer
    count--;
    notFull.signal();
    release(lock);
  }
}
```
Hoare-style和Hassen-style的区别: 是否在signal之后立刻进行切换.

## 消息传递


## 读者/写者问题
同步机制最困难的是设计合适的条件变量和计数量.

需要处理的互斥问题: 读写互斥, 写写互斥
```java
class ReaderFirst {
  Lock lock;
  int readerCnt = 0, writerCnt = 0, waitRead = 0;
  Cond fileAccess;
  
  void read() {
    acquire(lock);
    // 如果有写者, 不能读
    while (writerCnt != 0) {
      waitRead++;
      fileAccess.wait(lock);
      waitRead--;
    }
    readerCnt++;
    release(lock);
    // do read thing
    aquire(lock);
    readerCnt--;
    // 如果没有读者, 可以写
    if (readerCnt ==0 && waitRead == 0) canWrite.signal();
    release(lock);
  }
  void write() {
    acquire(lock);
    // 如果有读者或写者或者有等待读
    while (readerCnt + writerCnt + waitRead > 0) 
      fileAccess.wait();
    writeCnt = 1;
    release(lock);
    // do write thing
    acquire(lock);
    writeCnt = 0;
    fileAccess.signal();
    release(lock);
  }
}
```
具体实现与实验参考[读写者问题(读者优先, 写者优先)--基于管程的Java实现]()

并发模型中三个重要的模型:
- 生产者消费者模型(1v1)
- 读写者模型(一写多读)
- 哲学家就餐问题(资源竞争)

# 第六章 并发:死锁与饥饿


# 第九章 处理器调度

进程调度分为3种:
- 长程调度: 决定是否加入待运行进程池
- 中程调度: 决定是否部分或全部将进程放入内存
- 短程调度: 决定处理器下一个运行的进程

三种调度的关系:

![]()

引起进程切换的条件: 时钟中断, IO中断, 信号量, 系统调用

## 进程调度算法
进程调度算法首先分为两种: 抢占式和非抢占式
- 抢占式: 当一个进程占用处理器时, 可以被中断
- 非抢占式: 一旦选择了一个进程使用处理器, 只能等到其主动释放处理器.

![进程调度算法比较](http://cdn.hustcaid.com/Fi0FAAUENAcbT9MuSLnpyVmg17pt.png)

多级反馈调度:
- 基本概念: 使用n+1个就绪队列0-n, 优先级依次递减, 进程进入时首先被分配到最高优先级的队列, 当它首次被抢占并返回就绪态时, 被放置到下一个优先级的队列, 直到放置到最后一个队列. 除了最后一个队列每个队列都按照FCFS(first come first serve)的方式安排处理器.
- 为避免饥饿的优化: 不同优先级的队列的时间片长度不同, 优先级低的队列具有更长的时间片. 当一个进程在最后一个队列的等待时间超过一定时, 被移到优先级更高的队列.
- 特点: 对IO密集的进程友好, 能够在一个时间片内让出处理器就不会被降级. 不需要知道剩余执行时间. 